# File Permissions
### **Definition**
File permissions in Linux define **who can read, write, or execute a file or directory**. They control access for the **owner (user), group, and others**.
---
### **Why we use them**
We use file permissions to:

* **Protect data** â†’ stop unauthorized users from reading sensitive files.
* **Prevent changes** â†’ allow only specific users to modify files.
* **Control execution** â†’ ensure only the right users can run scripts/programs.
* **Support collaboration** â†’ groups can share files securely without exposing them to everyone.

File permissions are used to secure files and directories by defining what actions different users can perform.

Each file or directory in Linux has **three types of permissions** for **three categories of users**:

| Category       | Description                       |
| -------------- | --------------------------------- |
| **User (u)**   | The owner of the file             |
| **Group (g)**  | Users belonging to the same group |
| **Others (o)** | All other users                   |

And **three permission types**:

| Symbol | Permission | Meaning                                                             |
| ------ | ---------- | ------------------------------------------------------------------- |
| **r**  | Read       | Can view the file contents or list directory                        |
| **w**  | Write      | Can modify file contents or add/remove files in a directory         |
| **x**  | Execute    | Can run the file (if it's a script/program) or access the directory |

---

### **2. Symbolic Representation**

Youâ€™ll often see something like this with the `ls -l` command:

```
-rwxr-xr--
```

Breakdown:

* `-` â†’ Regular file
* `rwx` â†’ User has read, write, execute
* `r-x` â†’ Group has read and execute
* `r--` â†’ Others have read only

---

### **Types of Files in Linux**

1. **Regular File (`-`)**

   * Stores normal data (text, images, programs).
   * Example: `/etc/passwd`, `script.sh`

2. **Directory (`d`)**

   * A folder that contains other files/directories.
   * Example: `/home/konka`

3. **Character Device File (`c`)**

   * Handles data **character by character** (like keyboard, mouse, serial ports).
   * Example: `/dev/tty`, `/dev/null`

4. **Block Device File (`b`)**

   * Handles data in **blocks** (like hard drives, USBs).
   * Example: `/dev/sda`

5. **FIFO / Named Pipe (`p`)**

   * Used for **inter-process communication (IPC)**.
   * Example: `mkfifo pipe1`

6. **Socket (`s`)**

   * Used for **network communication** between processes.
   * Example: `/var/run/docker.sock`

7. **Symbolic Link (`l`)**

   * A shortcut or reference to another file.
   * Example: `ln -s /var/log/syslog mylog`

---

### **How to check file types**

Run:

```bash
ls -l
```

First character shows file type:

* `-` â†’ regular file
* `d` â†’ directory
* `c` â†’ character device
* `b` â†’ block device
* `p` â†’ pipe
* `s` â†’ socket
* `l` â†’ symlink

---

### **3. Numerical (Octal) Representation**

Each permission has a **numeric value**:

| Permission    | Value |
| ------------- | ----- |
| `r` (read)    | 4     |
| `w` (write)   | 2     |
| `x` (execute) | 1     |

Add them up for each category.

Example:

* `rwx` = 4 + 2 + 1 = **7**
* `r-x` = 4 + 0 + 1 = **5**
* `r--` = 4 + 0 + 0 = **4**

So:

```
-rwxr-xr--  =  754
```

---

### **4. `chmod` Command**

`chmod` (change mode) is used to modify file permissions.

#### Syntax:

```
chmod [options] mode file_name
```

---

### **5. Examples**

#### ðŸ”¹ **Using Numeric Mode**

1. **Give full permission to user, read-execute to group, read-only to others**

   ```bash
   chmod 754 file.txt
   ```

   â†’ rwx for user, r-x for group, r-- for others

2. **Everyone can read and write**

   ```bash
   chmod 666 file.txt
   ```

   â†’ rw- rw- rw-

3. **Only user can read and write**

   ```bash
   chmod 600 file.txt
   ```

   â†’ rw- --- ---

4. **Everyone can do everything**

   ```bash
   chmod 777 script.sh
   ```

   â†’ rwx rwx rwx

5. **User full, group and others execute only**

   ```bash
   chmod 711 script.sh
   ```

   â†’ rwx --x --x

---

#### ðŸ”¹ **Using Symbolic Mode**

1. **Add execute permission for user**

   ```bash
   chmod u+x script.sh
   ```

2. **Remove write permission from group**

   ```bash
   chmod g-w file.txt
   ```

3. **Give read permission to others**

   ```bash
   chmod o+r file.txt
   ```

4. **Set permissions exactly (user: read-write, group: read, others: none)**

   ```bash
   chmod u=rw,g=r,o= file.txt
   ```

5. **Give execute permission to everyone**

   ```bash
   chmod a+x script.sh
   ```

   *(a = all â†’ user, group, others)*

---

### **1. File Ownership in Linux**

Each file or directory in Linux has **two types of ownership**:

| Ownership Type   | Description                                                                                 |
| ---------------- | ------------------------------------------------------------------------------------------- |
| **User (Owner)** | The person who created or owns the file                                                     |
| **Group**        | A group that the file belongs to â€” all members of the group can have the same access rights |

You can check ownership using:

```bash
ls -l
```

Example output:

```
-rw-r--r-- 1 ubuntu developers 1200 Oct 6 10:00 file.txt
```

Here:

* **ubuntu** â†’ user (owner)
* **developers** â†’ group
* **1200** â†’ file size in bytes

---

### **2. Commands to Change Ownership**

#### ðŸ”¹ **Change Owner â†’ `chown`**

**Syntax:**

```bash
chown [new_owner] file_name
```

**Example:**

```bash
chown root file.txt
```

ðŸ‘‰ Changes the owner of `file.txt` to **root**.

---

#### ðŸ”¹ **Change Group â†’ `chgrp`**

**Syntax:**

```bash
chgrp [new_group] file_name
```

**Example:**

```bash
chgrp developers file.txt
```

ðŸ‘‰ Changes the group of `file.txt` to **developers**.

---

#### ðŸ”¹ **Change Both Owner and Group Together**

**Syntax:**

```bash
chown [new_owner]:[new_group] file_name
```

**Examples:**

1. Change owner and group:

   ```bash
   chown ubuntu:devops file.txt
   ```

   â†’ Owner becomes `ubuntu`, group becomes `devops`.

2. Change only group (skip owner):

   ```bash
   chown :developers file.txt
   ```

3. Change owner for multiple files:

   ```bash
   chown konka *.sh
   ```

---

### **3. Recursive Ownership Change**

If you want to change ownership of a directory and everything inside it:

```bash
chown -R ubuntu:devops /opt/myapp
```

ðŸ‘‰ `-R` means **recursive** â€” applies to all subfiles and subdirectories.

---

### **4. Verify Ownership**

After changing, check:

```bash
ls -l file.txt
```

---

### **Quick Summary Table**

| Command                    | Description      | Example                           |
| -------------------------- | ---------------- | --------------------------------- |
| `chown user file`          | Change owner     | `chown root file.txt`             |
| `chgrp group file`         | Change group     | `chgrp devops file.txt`           |
| `chown user:group file`    | Change both      | `chown ubuntu:devops file.txt`    |
| `chown -R user:group dir/` | Recursive change | `chown -R ubuntu:devops /opt/app` |

---
# SUID, SGID and Sticky Bit

## **1. Normal Permissions Recap**

Normally, a file executes with the **permissions of the user who runs it**.

Example:

```bash
-rwxr-xr-x  konka  devops  script.sh
```

If **user A** runs it â†’ it runs with **user Aâ€™s privileges**.

But sometimes, we need a program to run with **the file ownerâ€™s privileges**, not the callerâ€™s.
Thatâ€™s where **SUID, SGID, and Sticky Bit** come in.

---

## **2. SUID (Set User ID)**

ðŸ”¹ **Meaning:**
When a file with SUID is executed, it runs with the **permissions of the file owner**, not the user who runs it.

ðŸ”¹ **Symbol:**
`S` (or `s`) appears in the **user (owner)** permission field.

Example:

```
-rwsr-xr-x  1 root root  12345  /usr/bin/passwd
```

Here, the **`s`** in the user section (`rws`) means SUID is set.

ðŸ”¹ **Real Example:**
`/usr/bin/passwd` command.

* Owned by `root`.
* Normal users can change their passwords â€” but password data is stored in `/etc/shadow` (accessible only by root).
* So, when you run `passwd`, it runs **as root** temporarily because of SUID.

ðŸ”¹ **Set SUID:**

```bash
chmod u+s file.sh
```

ðŸ”¹ **Remove SUID:**

```bash
chmod u-s file.sh
```

ðŸ”¹ **Numerical Value:**
Add **4000** to normal permission.

Example:

```bash
chmod 4755 script.sh
```

â†’ SUID set + rwxr-xr-x

---

## **3. SGID (Set Group ID)**

ðŸ”¹ **Meaning (for files):**
When a file with SGID is executed, it runs with the **group privileges** of the file, not the group of the user who runs it.

ðŸ”¹ **Meaning (for directories):**
Any files created inside a directory with SGID will **inherit the group of that directory**, not the userâ€™s default group.

ðŸ”¹ **Symbol:**
`s` (or `S`) in the **group** field.

Example (for directory):

```
drwxr-sr-x  2 ubuntu devops  4096  /shared
```

ðŸ”¹ **Real Example (directory):**
If `/shared` has SGID set to `devops`, then any user creating files inside it will automatically make those files belong to **group devops** â€” ensures collaboration.

ðŸ”¹ **Set SGID:**

```bash
chmod g+s dir_name
```

ðŸ”¹ **Remove SGID:**

```bash
chmod g-s dir_name
```

ðŸ”¹ **Numerical Value:**
Add **2000** to normal permission.

Example:

```bash
chmod 2755 dir_name
```

---

## **4. Sticky Bit**

ðŸ”¹ **Meaning:**
Used **only on directories**.
It ensures that **only the fileâ€™s owner (or root)** can delete or rename the files inside that directory â€” even if others have write permission.

ðŸ”¹ **Symbol:**
`t` (or `T`) in the **others** field.

Example:

```
drwxrwxrwt  10 root  tmp  4096  /tmp
```

Notice the **`t`** at the end â†’ Sticky Bit is set.

ðŸ”¹ **Real Example:**
`/tmp` directory â€” shared by all users.
Everyone can write to it, but no one can delete another userâ€™s files.

ðŸ”¹ **Set Sticky Bit:**

```bash
chmod +t dir_name
```

ðŸ”¹ **Remove Sticky Bit:**

```bash
chmod -t dir_name
```

ðŸ”¹ **Numerical Value:**
Add **1000** to normal permission.

Example:

```bash
chmod 1777 dir_name
```

---

## **5. Summary Table**

| Special Bit    | Purpose                      | Applies To | Symbol              | Numeric Value | Example Command      |
| -------------- | ---------------------------- | ---------- | ------------------- | ------------- | -------------------- |
| **SUID**       | Run file as owner            | File       | `s` in user field   | 4000          | `chmod 4755 file`    |
| **SGID**       | Run as group / inherit group | File & Dir | `s` in group field  | 2000          | `chmod 2755 dir`     |
| **Sticky Bit** | Prevent others from deleting | Directory  | `t` in others field | 1000          | `chmod 1777 /shared` |

---

### **6. Example Demonstration**

```bash
# Create a test directory
mkdir /shared

# Give full permission to everyone
chmod 777 /shared

# Enable sticky bit
chmod +t /shared

# Verify
ls -ld /shared
# drwxrwxrwt  2 root root  4096 Oct 6 09:30 /shared
```

Now, every user can create files inside `/shared`,
but only **their own files** can be deleted by them.
---

# UMASK
## **1. Normal User (default umask)**

* Typically:

  ```
  umask = 0002
  ```
* Calculation:

  * File: 666 â€“ 002 = **664** â†’ `rw-rw-r--`
  * Dir:  777 â€“ 002 = **775** â†’ `rwxrwxr-x`

ðŸ‘‰ This allows group members to write to files (common in collaborative environments).

---

## **2. Root User (default umask)**

* Typically:

  ```
  umask = 0022
  ```
* Calculation:

  * File: 666 â€“ 022 = **644** â†’ `rw-r--r--`
  * Dir:  777 â€“ 022 = **755** â†’ `rwxr-xr-x`

ðŸ‘‰ This is stricter â€” others get only read/execute, no write.
Helps **avoid accidental security risks** if root creates files.

---

## **3. Why the Difference**

* **Normal users** â†’ can share files with their group (umask 0002).
* **Root** â†’ should never allow group/others to write by default, to **protect system files** (umask 0022).

---

## **4. Check Current umask**

```bash
umask
```

## **5. Change umask**

Temporarily:

```bash
umask 027
```

Permanently (per user): add to `~/.bashrc` or `~/.profile`.

System-wide: `/etc/profile` or `/etc/login.defs`.

---

âœ… **In short (interview answer):**

* Normal users: default umask is usually **0002** â†’ group can write.
* Root: default umask is usually **0022** â†’ more secure, prevents group/others from writing.