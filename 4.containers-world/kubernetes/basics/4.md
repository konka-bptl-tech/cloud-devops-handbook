### ✅ **1. How containers in a Pod communicate via localhost**

* A **Pod has a single network namespace** shared by all containers inside it.
* This means:

  * All containers in a Pod share the **same IP address**.
  * They can talk to each other using **localhost (127.0.0.1)** and **different ports**.

**Example:**

* Suppose a Pod has **two containers**:

  * **App Container** runs on port `8080`.
  * **Sidecar Logging Container** runs on port `9000`.

You can **cURL from one container to another like this**:

```bash
# Inside sidecar container
curl http://localhost:8080
```

Or vice versa:

```bash
# Inside app container
curl http://localhost:9000
```

✅ Both containers share the same network namespace, so `localhost` works.

---

### ✅ **2. How storage in a Pod can be shared across containers**

* Kubernetes allows containers in the same Pod to **share volumes**.
* The volume is defined at **Pod level**, and both containers mount it.
* Useful for:

  * **Sidecar logging pattern** (app writes logs → sidecar ships logs).
  * **Init container pattern** (init container prepares data → main container uses it).

**Example Pod manifest with shared volume:**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: shared-volume-pod
spec:
  containers:
    - name: app-container
      image: nginx
      volumeMounts:
        - name: shared-data
          mountPath: /usr/share/nginx/html
    - name: sidecar-container
      image: busybox
      command: ['sh', '-c', 'echo "Hello from sidecar" > /data/index.html; sleep 3600']
      volumeMounts:
        - name: shared-data
          mountPath: /data
  volumes:
    - name: shared-data
      emptyDir: {}
```

✅ **How it works:**

* The `emptyDir` volume is created when the Pod starts.
* Sidecar container writes `index.html` in `/data`.
* Nginx container serves the same file from `/usr/share/nginx/html`.

---

### ✅ **Use Cases of Sidecar & Init Containers**

* **Sidecar**:

  * Logging agent (e.g., Fluentd).
  * Proxy (e.g., Envoy for Istio).
  * Data fetcher/updater.
* **Init Container**:

  * Database migration before app starts.
  * Pulling secrets/config files.

---

### ✅ **1. Create a Pod using `kubectl`**

Run a simple Nginx Pod:

```bash
kubectl run mypod --image=nginx
```

Create it in a specific namespace:

```bash
kubectl run mypod --image=nginx -n dev
```

---

### ✅ **2. Generate YAML from a `kubectl` command**


```bash
kubectl run mypod --image=nginx --dry-run=client -o yaml
```

This will **print the Pod manifest** without applying it.
To **save it to a file**:

```bash
kubectl run mypod --image=nginx --dry-run=client -o yaml > mypod.yaml
```

---

### ✅ **3. Apply the YAML file**

```bash
kubectl apply -f mypod.yaml
```

---

### ✅ **4. All Common `kubectl` Commands (Cheat Sheet)**

#### **Pod Management**

```bash
kubectl get pods                   # List Pods
kubectl describe pod <pod-name>    # Show Pod details
kubectl delete pod <pod-name>      # Delete Pod
kubectl logs <pod-name>            # View Pod logs
kubectl exec -it <pod-name> -- sh  # Exec into Pod
```

#### **Deployment Management**

```bash
kubectl create deployment myapp --image=nginx
kubectl get deployments
kubectl scale deployment myapp --replicas=3
kubectl rollout status deployment myapp
kubectl rollout undo deployment myapp
```

#### **Service Management**

```bash
kubectl expose pod mypod --port=80 --type=NodePort
kubectl get svc
kubectl delete svc mypod
```

#### **Namespaces**

```bash
kubectl get namespaces
kubectl create namespace dev
kubectl get pods -n dev
```

#### **Config & Secrets**

```bash
kubectl create configmap myconfig --from-literal=key=value
kubectl create secret generic mysecret --from-literal=password=12345
```

#### **Resources & YAML**

```bash
kubectl get all
kubectl apply -f file.yaml
kubectl delete -f file.yaml
kubectl explain pod      # Show resource details
```

#### **Context & Cluster**

```bash
kubectl config get-contexts
kubectl config use-context <context-name>
kubectl cluster-info
```

---
