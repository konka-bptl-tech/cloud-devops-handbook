# My Understanding
Kustomization as per my understanding Don't touch actual yaml files modify as per you requirement through overlays kustomization is a native tool to manage different configuration per env without modifying actual manifests but patch what ever you want through overlays making it simple and safe

---

### ğŸ”¹ Key Points About Kustomize

1. **Base YAMLs stay untouched**

   * Your `deployment.yaml`, `statefulset.yaml`, `service.yaml`, etc., in the base folder are never modified.
   * They act as the **single source of truth**.

2. **Overlays modify behavior per environment**

   * Overlays (like `dev`, `prod`) **patch** the base manifests for environment-specific settings.
   * You can change things like:

     * Images
     * Labels
     * Resource limits/requests
     * Probes
     * ConfigMaps / Secrets references
     * StorageClass for PVCs

3. **Patch-only approach is simple and safe**

   * You donâ€™t duplicate the entire YAML â€” only the parts you need to change.
   * Makes it easier to maintain and avoids human errors.

4. **Native K8s tool**

   * No extra templating language or rendering engine is required (unlike Helm).
   * Generates fully valid Kubernetes manifests after applying overlays.

5. **Supports generators**

   * `configMapGenerator` and `secretGenerator` let you create configs or secrets dynamically.
   * These can also be patched per environment.

---

### ğŸ”¹ In short:

> Kustomize = â€œKeep your base YAMLs clean & generic â†’ overlay patches per environment â†’ apply fully merged manifests to Kubernetes.â€

---
## ğŸ”¹ What is Kustomization?

* **Kustomize** is a Kubernetes-native way to **customize raw YAML manifests** without using templates.
* It works by **overlaying patches** on top of your base YAMLs.
* You donâ€™t need a separate tool (since `kubectl` already supports it: `kubectl apply -k ./`).

---

## ğŸ”¹ Why do we use Kustomize?

1. **No templates, pure YAML** â†’ You donâ€™t learn a new language like Helm templating.
2. **Overlays for environments** â†’ Example: one base config, overlays for `dev`, `staging`, `prod`.
3. **Reusable manifests** â†’ Instead of duplicating YAMLs, you patch only what changes.
4. **GitOps friendly** â†’ Easy integration with tools like ArgoCD or Flux.

---

## ğŸ”¹ Comparison: Normal YAML vs Helm vs Kustomization

| Feature                   | **Normal YAML**       | **Helm**                                          | **Kustomize**                       |
| ------------------------- | --------------------- | ------------------------------------------------- | ----------------------------------- |
| **Approach**              | Write static YAML     | Template-based (Go templates + values)            | Patch-based (overlay YAMLs)         |
| **Reusability**           | Poor (copy-paste)     | High (values + templates)                         | Medium (base + overlays)            |
| **Complexity**            | Simple but repetitive | Higher (templating, charts)                       | Medium (pure YAML + patches)        |
| **Customization**         | Manual edits          | Values.yaml + CLI overrides                       | Kustomization.yaml overlays         |
| **Ecosystem**             | None                  | Huge (pre-built charts: NGINX, Prometheus, Istio) | Smaller, but used in GitOps         |
| **Rollback / Versioning** | No                    | Yes (Helm history)                                | No (depends on Git history)         |
| **Learning Curve**        | Very low              | Medium (templating)                               | Low (pure YAML, but layering logic) |

ğŸ‘‰ **When to use**:

* **Normal YAML** â†’ For very simple apps.
* **Helm** â†’ When you need packaging, templating, reusability, rollbacks.
* **Kustomize** â†’ When you want **YAML-only customization** with overlays (good for GitOps).

---

## ğŸ”¹ Folder Structure of Kustomization

### Example: `nginx` app with `dev` and `prod`

```
kustomize-example/
â”‚
â”œâ”€â”€ base/
â”‚   â”œâ”€â”€ deployment.yaml
â”‚   â”œâ”€â”€ service.yaml
â”‚   â””â”€â”€ kustomization.yaml
â”‚
â””â”€â”€ overlays/
    â”œâ”€â”€ dev/
    â”‚   â”œâ”€â”€ kustomization.yaml
    â”‚   â””â”€â”€ patch.yaml
    â”‚
    â””â”€â”€ prod/
        â”œâ”€â”€ kustomization.yaml
        â””â”€â”€ patch.yaml
```

### `base/kustomization.yaml`

```yaml
resources:
  - deployment.yaml
  - service.yaml
```

### `overlays/dev/kustomization.yaml`

```yaml
resources:
  - ../../base
patchesStrategicMerge:
  - patch.yaml
```

### `overlays/dev/patch.yaml`

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
spec:
  replicas: 2
```

ğŸ‘‰ Now, apply for dev:

```bash
kubectl apply -k overlays/dev/
```

---

âœ… **Summary**

* **Normal YAML** â†’ static, copy-paste.
* **Helm** â†’ dynamic, reusable, package manager.
* **Kustomize** â†’ YAML overlays, simple customization, good for GitOps.

---
### âœ… BASIC RULES

| Operation                                                | Rule                                                                                       |
| -------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
| **Match by name**                                        | In lists (like containers, volumes), **it matches items by `name:`** and patches that item |
| **Only patched fields are changed**                      | If a field is not mentioned in the patch â†’ it stays untouched                              |
| **Full sub-block needed if API expects required fields** | e.g., for `httpGet` â†’ Kubernetes needs **both `path` & `port`**                            |
| **Lists are merged, not overwritten**                    | It does **NOT replace full list**, only patches matching items                             |
| **To delete a field**                                    | Use `null` â†’ `field: null`                                                                 |
| **Order of fields does not matter**                      | Only matching keys matter                                                                  |

---

### ğŸ¯ EXAMPLE â€” How merging works

Base:

```yaml
containers:
  - name: app
    image: app:v1
    ports:
      - containerPort: 8080
```

Patch (Strategic Merge Patch):

```yaml
containers:
  - name: app
    image: app:v2
```

âœ… Final result:

```yaml
containers:
  - name: app
    image: app:v2   # updated
    ports:
      - containerPort: 8080  # untouched
```

---

### âš  IMPORTANT â€” Sub-fields must be **complete** if API needs

If you write:

```yaml
livenessProbe:
  httpGet:
    path: /ping
```

âŒ ERROR â€” because `port` is missing â†’ API requires it

âœ… Correct patch:

```yaml
livenessProbe:
  httpGet:
    path: /ping
    port: 8080
```

---

### ğŸ—‘ How to REMOVE something

```yaml
spec:
  template:
    spec:
      containers:
        - name: app
          ports: null
```

â†’ `ports` will be **deleted completely**

---