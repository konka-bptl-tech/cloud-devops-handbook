# My Understanding
Kustomization as per my understanding Don't touch actual yaml files modify as per you requirement through overlays kustomization is a native tool to manage different configuration per env without modifying actual manifests but patch what ever you want through overlays making it simple and safe

---

### ğŸ”¹ Key Points About Kustomize

1. **Base YAMLs stay untouched**

   * Your `deployment.yaml`, `statefulset.yaml`, `service.yaml`, etc., in the base folder are never modified.
   * They act as the **single source of truth**.

2. **Overlays modify behavior per environment**

   * Overlays (like `dev`, `prod`) **patch** the base manifests for environment-specific settings.
   * You can change things like:

     * Images
     * Labels
     * Resource limits/requests
     * Probes
     * ConfigMaps / Secrets references
     * StorageClass for PVCs

3. **Patch-only approach is simple and safe**

   * You donâ€™t duplicate the entire YAML â€” only the parts you need to change.
   * Makes it easier to maintain and avoids human errors.

4. **Native K8s tool**

   * No extra templating language or rendering engine is required (unlike Helm).
   * Generates fully valid Kubernetes manifests after applying overlays.

5. **Supports generators**

   * `configMapGenerator` and `secretGenerator` let you create configs or secrets dynamically.
   * These can also be patched per environment.

---

### ğŸ”¹ In short:

> Kustomize = â€œKeep your base YAMLs clean & generic â†’ overlay patches per environment â†’ apply fully merged manifests to Kubernetes.â€

---
## ğŸ”¹ What is Kustomization?

* **Kustomize** is a Kubernetes-native way to **customize raw YAML manifests** without using templates.
* It works by **overlaying patches** on top of your base YAMLs.
* You donâ€™t need a separate tool (since `kubectl` already supports it: `kubectl apply -k ./`).

---

## ğŸ”¹ Why do we use Kustomize?

1. **No templates, pure YAML** â†’ You donâ€™t learn a new language like Helm templating.
2. **Overlays for environments** â†’ Example: one base config, overlays for `dev`, `staging`, `prod`.
3. **Reusable manifests** â†’ Instead of duplicating YAMLs, you patch only what changes.
4. **GitOps friendly** â†’ Easy integration with tools like ArgoCD or Flux.

---

## ğŸ”¹ Comparison: Normal YAML vs Helm vs Kustomization

| Feature                   | **Normal YAML**       | **Helm**                                          | **Kustomize**                       |
| ------------------------- | --------------------- | ------------------------------------------------- | ----------------------------------- |
| **Approach**              | Write static YAML     | Template-based (Go templates + values)            | Patch-based (overlay YAMLs)         |
| **Reusability**           | Poor (copy-paste)     | High (values + templates)                         | Medium (base + overlays)            |
| **Complexity**            | Simple but repetitive | Higher (templating, charts)                       | Medium (pure YAML + patches)        |
| **Customization**         | Manual edits          | Values.yaml + CLI overrides                       | Kustomization.yaml overlays         |
| **Ecosystem**             | None                  | Huge (pre-built charts: NGINX, Prometheus, Istio) | Smaller, but used in GitOps         |
| **Rollback / Versioning** | No                    | Yes (Helm history)                                | No (depends on Git history)         |
| **Learning Curve**        | Very low              | Medium (templating)                               | Low (pure YAML, but layering logic) |

ğŸ‘‰ **When to use**:

* **Normal YAML** â†’ For very simple apps.
* **Helm** â†’ When you need packaging, templating, reusability, rollbacks.
* **Kustomize** â†’ When you want **YAML-only customization** with overlays (good for GitOps).

---

## ğŸ”¹ Folder Structure of Kustomization

### Example: `nginx` app with `dev` and `prod`

```
kustomize-example/
â”‚
â”œâ”€â”€ base/
â”‚   â”œâ”€â”€ deployment.yaml
â”‚   â”œâ”€â”€ service.yaml
â”‚   â””â”€â”€ kustomization.yaml
â”‚
â””â”€â”€ overlays/
    â”œâ”€â”€ dev/
    â”‚   â”œâ”€â”€ kustomization.yaml
    â”‚   â””â”€â”€ patch.yaml
    â”‚
    â””â”€â”€ prod/
        â”œâ”€â”€ kustomization.yaml
        â””â”€â”€ patch.yaml
```

### `base/kustomization.yaml`

```yaml
resources:
  - deployment.yaml
  - service.yaml
```

### `overlays/dev/kustomization.yaml`

```yaml
resources:
  - ../../base
patchesStrategicMerge:
  - patch.yaml
```

### `overlays/dev/patch.yaml`

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
spec:
  replicas: 2
```

ğŸ‘‰ Now, apply for dev:

```bash
kubectl apply -k overlays/dev/
```

---

âœ… **Summary**

* **Normal YAML** â†’ static, copy-paste.
* **Helm** â†’ dynamic, reusable, package manager.
* **Kustomize** â†’ YAML overlays, simple customization, good for GitOps.

---

### âœ… BASIC RULES

| Operation                                                | Rule                                                                                       |
| -------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
| **Match by name**                                        | In lists (like containers, volumes), **it matches items by `name:`** and patches that item |
| **Only patched fields are changed**                      | If a field is not mentioned in the patch â†’ it stays untouched                              |
| **Full sub-block needed if API expects required fields** | e.g., for `httpGet` â†’ Kubernetes needs **both `path` & `port`**                            |
| **Lists are merged, not overwritten**                    | It does **NOT replace full list**, only patches matching items                             |
| **To delete a field**                                    | Use `null` â†’ `field: null`                                                                 |
| **Order of fields does not matter**                      | Only matching keys matter                                                                  |

---

### ğŸ¯ EXAMPLE â€” How merging works

Base:

```yaml
containers:
  - name: app
    image: app:v1
    ports:
      - containerPort: 8080
```

Patch (Strategic Merge Patch):

```yaml
containers:
  - name: app
    image: app:v2
```

âœ… Final result:

```yaml
containers:
  - name: app
    image: app:v2   # updated
    ports:
      - containerPort: 8080  # untouched
```

---

### âš  IMPORTANT â€” Sub-fields must be **complete** if API needs

If you write:

```yaml
livenessProbe:
  httpGet:
    path: /ping
```

âŒ ERROR â€” because `port` is missing â†’ API requires it

âœ… Correct patch:

```yaml
livenessProbe:
  httpGet:
    path: /ping
    port: 8080
```

---

### ğŸ—‘ How to REMOVE something

```yaml
spec:
  template:
    spec:
      containers:
        - name: app
          ports: null
```

â†’ `ports` will be **deleted completely**

---


Great! Hereâ€™s a **Kustomize patching cheat-sheet** for Kubernetes resources like StatefulSets, Services, and Secrets. Iâ€™ve kept it simple, clear, and practical.

---

## **1ï¸âƒ£ StatefulSet**

| Field                                    | Can Patch?   | Notes / Examples                                                                  |
| ---------------------------------------- | ------------ | --------------------------------------------------------------------------------- |
| `metadata.labels`                        | âœ… Mutable    | Can add labels, used for organizing/selection.                                    |
| `metadata.name`                          | âŒ Immutable  | Name cannot change in patch; must match base.                                     |
| `spec.replicas`                          | âœ… Mutable    | Change number of replicas per environment.                                        |
| `spec.selector`                          | âŒ Immutable  | Selector labels must match `template.metadata.labels`. Cannot change.             |
| `spec.template.metadata.labels`          | âœ… Mutable    | Can add labels, but **must include all selector labels**.                         |
| `spec.template.spec.containers[*].image` | âœ… Mutable    | Change image per environment.                                                     |
| `spec.template.spec.containers[*].env`   | âœ… Mutable    | Override environment variables.                                                   |
| `spec.volumeClaimTemplates`              | âš ï¸ Partially | You can change storage size/class in overlays **only if you keep the same name**. |
| `spec.template.spec.containers[*].name`  | âŒ Immutable  | Cannot change container names.                                                    |

**ğŸ’¡ Golden Rule:**
`spec.selector.matchLabels` **must always match** `spec.template.metadata.labels`. Otherwise, StatefulSet is invalid.

---

## **2ï¸âƒ£ Service**

| Field             | Can Patch?                  | Notes / Examples                                 |
| ----------------- | --------------------------- | ------------------------------------------------ |
| `metadata.labels` | âœ… Mutable                   | Add environment-specific labels.                 |
| `metadata.name`   | âŒ Immutable                 | Name must match base.                            |
| `spec.selector`   | âœ… Mutable                   | Can override, but should match labels on pods.   |
| `spec.ports`      | âœ… Mutable                   | Can patch ports if needed.                       |
| `spec.type`       | âš ï¸ Immutable after creation | Changing ClusterIP type after creation may fail. |

**ğŸ’¡ Tip:** Always check that service selectors match pod labels.

---

## **3ï¸âƒ£ Secret / ExternalSecret**

| Field               | Can Patch?   | Notes / Examples                                  |
| ------------------- | ------------ | ------------------------------------------------- |
| `metadata.labels`   | âœ… Mutable    | Environment-specific labeling.                    |
| `metadata.name`     | âŒ Immutable  | Name must match base for patching.                |
| `data / stringData` | âœ… Mutable    | Override values per environment.                  |
| `type`              | âš ï¸ Immutable | Cannot change type in patch (e.g., Opaque â†’ TLS). |
| `namespace`         | âŒ Immutable  | Namespace is fixed; cannot patch from overlay.    |

---

## **Kustomize Overlay Tips**

1. **Patch only mutable fields**: image, env, labels, resource limits, secrets.
2. **Do not try to patch immutable fields**: name, selector, container name.
3. **Use overlays for environment differences**, not for completely new apps.
4. **Use ExternalSecrets overlays** to point to different Vault paths or Secret names per environment.
5. **Avoid creating base secrets you donâ€™t need**: manage secrets via overlays and external secrets.

---


## **ğŸ¯ Base â†’ Overlay â†’ Patch Workflow**

### **1ï¸âƒ£ Base Folder Structure**

```
base/
â”œâ”€ mysql/
â”‚   â”œâ”€ kustomization.yaml
â”‚   â”œâ”€ statefulset.yaml      # base StatefulSet
â”‚   â”œâ”€ service.yaml          # base Service
â”‚   â””â”€ secret.yaml           # base Secret (optional)
â”œâ”€ redis/
â”‚   â”œâ”€ kustomization.yaml
â”‚   â”œâ”€ statefulset.yaml
â”‚   â””â”€ service.yaml
â””â”€ external-secret.yaml      # Base ExternalSecret pointing to Vault
```

**Example Base StatefulSet**

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: crud-mysql
spec:
  serviceName: crud-mysql
  replicas: 1
  selector:
    matchLabels:
      app: crud-mysql
  template:
    metadata:
      labels:
        app: crud-mysql
    spec:
      containers:
        - name: crud-mysql
          image: crud-mysql:v1
          env:
            - name: MYSQL_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: crud-secrets
                  key: MYSQL_ROOT_PASSWORD
```

---

### **2ï¸âƒ£ Overlay Folder Structure**

```
overlays/prod/
â”œâ”€ kustomization.yaml
â”œâ”€ mysql-patch.yaml         # Only patch mutable fields
â”œâ”€ external-secret-patch.yaml
```

**Overlay Patch Example â€“ StatefulSet**

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: crud-mysql      # Must match base name
spec:
  template:
    metadata:
      labels:
        env: prod       # Add env label
    spec:
      containers:
        - name: crud-mysql   # Must match base container name
          image: siva9666/crud:mysql-v1  # Override image
          env:
            - name: MYSQL_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: prod-mysql-secret
                  key: MYSQL_ROOT_PASSWORD
```

**Overlay Patch Example â€“ ExternalSecret**

```yaml
apiVersion: external-secrets.io/v1
kind: ExternalSecret
metadata:
  name: external-secret-mysql   # Must match base name
  namespace: crud
spec:
  target:
    name: prod-mysql-secret      # Only override target Secret name
  data:
    - remoteRef:
        key: prod/mysql          # Override Vault path
        property: MYSQL_ROOT_PASSWORD
```

---

### **3ï¸âƒ£ Overlay Kustomization.yaml**

```yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

resources:
  - ../../../base/mysql
  - ../../../base/redis
  - external-secret-patch.yaml

patches:
  - path: mysql-patch.yaml
    target:
      kind: StatefulSet
      name: crud-mysql
```

**âœ… Key Rules**

1. **Name must match base** if you want to patch it.
2. **Patch only mutable fields**:

   * labels
   * env
   * image
   * resource limits
3. **Immutable fields cannot change**:

   * StatefulSet `selector`
   * Container `name`
   * Secret `type`
4. **Use overlay to override per environment** (prod, dev, staging).
5. **ExternalSecrets overlay** can point to different Vault paths or Secret names.

---

This approach ensures:

* Base contains **common configuration** for all environments.
* Overlay applies **environment-specific changes** safely.
* You never accidentally try to patch immutable fields.
* Secrets created by ExternalSecrets donâ€™t collide with base Secrets.

---