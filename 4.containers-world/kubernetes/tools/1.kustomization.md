# My Understanding
Kustomization as per my understanding Don't touch actual yaml files modify as per you requirement through overlays kustomization is a native tool to manage different configuration per env without modifying actual manifests but patch what ever you want through overlays making it simple and safe

---

### 🔹 Key Points About Kustomize

1. **Base YAMLs stay untouched**

   * Your `deployment.yaml`, `statefulset.yaml`, `service.yaml`, etc., in the base folder are never modified.
   * They act as the **single source of truth**.

2. **Overlays modify behavior per environment**

   * Overlays (like `dev`, `prod`) **patch** the base manifests for environment-specific settings.
   * You can change things like:

     * Images
     * Labels
     * Resource limits/requests
     * Probes
     * ConfigMaps / Secrets references
     * StorageClass for PVCs

3. **Patch-only approach is simple and safe**

   * You don’t duplicate the entire YAML — only the parts you need to change.
   * Makes it easier to maintain and avoids human errors.

4. **Native K8s tool**

   * No extra templating language or rendering engine is required (unlike Helm).
   * Generates fully valid Kubernetes manifests after applying overlays.

5. **Supports generators**

   * `configMapGenerator` and `secretGenerator` let you create configs or secrets dynamically.
   * These can also be patched per environment.

---

### 🔹 In short:

> Kustomize = “Keep your base YAMLs clean & generic → overlay patches per environment → apply fully merged manifests to Kubernetes.”

---
## 🔹 What is Kustomization?

* **Kustomize** is a Kubernetes-native way to **customize raw YAML manifests** without using templates.
* It works by **overlaying patches** on top of your base YAMLs.
* You don’t need a separate tool (since `kubectl` already supports it: `kubectl apply -k ./`).

---

## 🔹 Why do we use Kustomize?

1. **No templates, pure YAML** → You don’t learn a new language like Helm templating.
2. **Overlays for environments** → Example: one base config, overlays for `dev`, `staging`, `prod`.
3. **Reusable manifests** → Instead of duplicating YAMLs, you patch only what changes.
4. **GitOps friendly** → Easy integration with tools like ArgoCD or Flux.

---

## 🔹 Comparison: Normal YAML vs Helm vs Kustomization

| Feature                   | **Normal YAML**       | **Helm**                                          | **Kustomize**                       |
| ------------------------- | --------------------- | ------------------------------------------------- | ----------------------------------- |
| **Approach**              | Write static YAML     | Template-based (Go templates + values)            | Patch-based (overlay YAMLs)         |
| **Reusability**           | Poor (copy-paste)     | High (values + templates)                         | Medium (base + overlays)            |
| **Complexity**            | Simple but repetitive | Higher (templating, charts)                       | Medium (pure YAML + patches)        |
| **Customization**         | Manual edits          | Values.yaml + CLI overrides                       | Kustomization.yaml overlays         |
| **Ecosystem**             | None                  | Huge (pre-built charts: NGINX, Prometheus, Istio) | Smaller, but used in GitOps         |
| **Rollback / Versioning** | No                    | Yes (Helm history)                                | No (depends on Git history)         |
| **Learning Curve**        | Very low              | Medium (templating)                               | Low (pure YAML, but layering logic) |

👉 **When to use**:

* **Normal YAML** → For very simple apps.
* **Helm** → When you need packaging, templating, reusability, rollbacks.
* **Kustomize** → When you want **YAML-only customization** with overlays (good for GitOps).

---

## 🔹 Folder Structure of Kustomization

### Example: `nginx` app with `dev` and `prod`

```
kustomize-example/
│
├── base/
│   ├── deployment.yaml
│   ├── service.yaml
│   └── kustomization.yaml
│
└── overlays/
    ├── dev/
    │   ├── kustomization.yaml
    │   └── patch.yaml
    │
    └── prod/
        ├── kustomization.yaml
        └── patch.yaml
```

### `base/kustomization.yaml`

```yaml
resources:
  - deployment.yaml
  - service.yaml
```

### `overlays/dev/kustomization.yaml`

```yaml
resources:
  - ../../base
patchesStrategicMerge:
  - patch.yaml
```

### `overlays/dev/patch.yaml`

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
spec:
  replicas: 2
```

👉 Now, apply for dev:

```bash
kubectl apply -k overlays/dev/
```

---

✅ **Summary**

* **Normal YAML** → static, copy-paste.
* **Helm** → dynamic, reusable, package manager.
* **Kustomize** → YAML overlays, simple customization, good for GitOps.

---
### ✅ BASIC RULES

| Operation                                                | Rule                                                                                       |
| -------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
| **Match by name**                                        | In lists (like containers, volumes), **it matches items by `name:`** and patches that item |
| **Only patched fields are changed**                      | If a field is not mentioned in the patch → it stays untouched                              |
| **Full sub-block needed if API expects required fields** | e.g., for `httpGet` → Kubernetes needs **both `path` & `port`**                            |
| **Lists are merged, not overwritten**                    | It does **NOT replace full list**, only patches matching items                             |
| **To delete a field**                                    | Use `null` → `field: null`                                                                 |
| **Order of fields does not matter**                      | Only matching keys matter                                                                  |

---

### 🎯 EXAMPLE — How merging works

Base:

```yaml
containers:
  - name: app
    image: app:v1
    ports:
      - containerPort: 8080
```

Patch (Strategic Merge Patch):

```yaml
containers:
  - name: app
    image: app:v2
```

✅ Final result:

```yaml
containers:
  - name: app
    image: app:v2   # updated
    ports:
      - containerPort: 8080  # untouched
```

---

### ⚠ IMPORTANT — Sub-fields must be **complete** if API needs

If you write:

```yaml
livenessProbe:
  httpGet:
    path: /ping
```

❌ ERROR — because `port` is missing → API requires it

✅ Correct patch:

```yaml
livenessProbe:
  httpGet:
    path: /ping
    port: 8080
```

---

### 🗑 How to REMOVE something

```yaml
spec:
  template:
    spec:
      containers:
        - name: app
          ports: null
```

→ `ports` will be **deleted completely**

---