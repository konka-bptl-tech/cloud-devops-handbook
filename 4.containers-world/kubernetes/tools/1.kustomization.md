# My Understanding
Kustomization as per my understanding Don't touch actual yaml files modify as per you requirement through overlays kustomization is a native tool to manage different configuration per env without modifying actual manifests but patch what ever you want through overlays making it simple and safe

---

### 🔹 Key Points About Kustomize

1. **Base YAMLs stay untouched**

   * Your `deployment.yaml`, `statefulset.yaml`, `service.yaml`, etc., in the base folder are never modified.
   * They act as the **single source of truth**.

2. **Overlays modify behavior per environment**

   * Overlays (like `dev`, `prod`) **patch** the base manifests for environment-specific settings.
   * You can change things like:

     * Images
     * Labels
     * Resource limits/requests
     * Probes
     * ConfigMaps / Secrets references
     * StorageClass for PVCs

3. **Patch-only approach is simple and safe**

   * You don’t duplicate the entire YAML — only the parts you need to change.
   * Makes it easier to maintain and avoids human errors.

4. **Native K8s tool**

   * No extra templating language or rendering engine is required (unlike Helm).
   * Generates fully valid Kubernetes manifests after applying overlays.

5. **Supports generators**

   * `configMapGenerator` and `secretGenerator` let you create configs or secrets dynamically.
   * These can also be patched per environment.

---

### 🔹 In short:

> Kustomize = “Keep your base YAMLs clean & generic → overlay patches per environment → apply fully merged manifests to Kubernetes.”

---
## 🔹 What is Kustomization?

* **Kustomize** is a Kubernetes-native way to **customize raw YAML manifests** without using templates.
* It works by **overlaying patches** on top of your base YAMLs.
* You don’t need a separate tool (since `kubectl` already supports it: `kubectl apply -k ./`).

---

## 🔹 Why do we use Kustomize?

1. **No templates, pure YAML** → You don’t learn a new language like Helm templating.
2. **Overlays for environments** → Example: one base config, overlays for `dev`, `staging`, `prod`.
3. **Reusable manifests** → Instead of duplicating YAMLs, you patch only what changes.
4. **GitOps friendly** → Easy integration with tools like ArgoCD or Flux.

---

## 🔹 Comparison: Normal YAML vs Helm vs Kustomization

| Feature                   | **Normal YAML**       | **Helm**                                          | **Kustomize**                       |
| ------------------------- | --------------------- | ------------------------------------------------- | ----------------------------------- |
| **Approach**              | Write static YAML     | Template-based (Go templates + values)            | Patch-based (overlay YAMLs)         |
| **Reusability**           | Poor (copy-paste)     | High (values + templates)                         | Medium (base + overlays)            |
| **Complexity**            | Simple but repetitive | Higher (templating, charts)                       | Medium (pure YAML + patches)        |
| **Customization**         | Manual edits          | Values.yaml + CLI overrides                       | Kustomization.yaml overlays         |
| **Ecosystem**             | None                  | Huge (pre-built charts: NGINX, Prometheus, Istio) | Smaller, but used in GitOps         |
| **Rollback / Versioning** | No                    | Yes (Helm history)                                | No (depends on Git history)         |
| **Learning Curve**        | Very low              | Medium (templating)                               | Low (pure YAML, but layering logic) |

👉 **When to use**:

* **Normal YAML** → For very simple apps.
* **Helm** → When you need packaging, templating, reusability, rollbacks.
* **Kustomize** → When you want **YAML-only customization** with overlays (good for GitOps).

---

## 🔹 Folder Structure of Kustomization

### Example: `nginx` app with `dev` and `prod`

```
kustomize-example/
│
├── base/
│   ├── deployment.yaml
│   ├── service.yaml
│   └── kustomization.yaml
│
└── overlays/
    ├── dev/
    │   ├── kustomization.yaml
    │   └── patch.yaml
    │
    └── prod/
        ├── kustomization.yaml
        └── patch.yaml
```

### `base/kustomization.yaml`

```yaml
resources:
  - deployment.yaml
  - service.yaml
```

### `overlays/dev/kustomization.yaml`

```yaml
resources:
  - ../../base
patchesStrategicMerge:
  - patch.yaml
```

### `overlays/dev/patch.yaml`

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
spec:
  replicas: 2
```

👉 Now, apply for dev:

```bash
kubectl apply -k overlays/dev/
```

---

✅ **Summary**

* **Normal YAML** → static, copy-paste.
* **Helm** → dynamic, reusable, package manager.
* **Kustomize** → YAML overlays, simple customization, good for GitOps.

---

### ✅ BASIC RULES

| Operation                                                | Rule                                                                                       |
| -------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
| **Match by name**                                        | In lists (like containers, volumes), **it matches items by `name:`** and patches that item |
| **Only patched fields are changed**                      | If a field is not mentioned in the patch → it stays untouched                              |
| **Full sub-block needed if API expects required fields** | e.g., for `httpGet` → Kubernetes needs **both `path` & `port`**                            |
| **Lists are merged, not overwritten**                    | It does **NOT replace full list**, only patches matching items                             |
| **To delete a field**                                    | Use `null` → `field: null`                                                                 |
| **Order of fields does not matter**                      | Only matching keys matter                                                                  |

---

### 🎯 EXAMPLE — How merging works

Base:

```yaml
containers:
  - name: app
    image: app:v1
    ports:
      - containerPort: 8080
```

Patch (Strategic Merge Patch):

```yaml
containers:
  - name: app
    image: app:v2
```

✅ Final result:

```yaml
containers:
  - name: app
    image: app:v2   # updated
    ports:
      - containerPort: 8080  # untouched
```

---

### ⚠ IMPORTANT — Sub-fields must be **complete** if API needs

If you write:

```yaml
livenessProbe:
  httpGet:
    path: /ping
```

❌ ERROR — because `port` is missing → API requires it

✅ Correct patch:

```yaml
livenessProbe:
  httpGet:
    path: /ping
    port: 8080
```

---

### 🗑 How to REMOVE something

```yaml
spec:
  template:
    spec:
      containers:
        - name: app
          ports: null
```

→ `ports` will be **deleted completely**

---


Great! Here’s a **Kustomize patching cheat-sheet** for Kubernetes resources like StatefulSets, Services, and Secrets. I’ve kept it simple, clear, and practical.

---

## **1️⃣ StatefulSet**

| Field                                    | Can Patch?   | Notes / Examples                                                                  |
| ---------------------------------------- | ------------ | --------------------------------------------------------------------------------- |
| `metadata.labels`                        | ✅ Mutable    | Can add labels, used for organizing/selection.                                    |
| `metadata.name`                          | ❌ Immutable  | Name cannot change in patch; must match base.                                     |
| `spec.replicas`                          | ✅ Mutable    | Change number of replicas per environment.                                        |
| `spec.selector`                          | ❌ Immutable  | Selector labels must match `template.metadata.labels`. Cannot change.             |
| `spec.template.metadata.labels`          | ✅ Mutable    | Can add labels, but **must include all selector labels**.                         |
| `spec.template.spec.containers[*].image` | ✅ Mutable    | Change image per environment.                                                     |
| `spec.template.spec.containers[*].env`   | ✅ Mutable    | Override environment variables.                                                   |
| `spec.volumeClaimTemplates`              | ⚠️ Partially | You can change storage size/class in overlays **only if you keep the same name**. |
| `spec.template.spec.containers[*].name`  | ❌ Immutable  | Cannot change container names.                                                    |

**💡 Golden Rule:**
`spec.selector.matchLabels` **must always match** `spec.template.metadata.labels`. Otherwise, StatefulSet is invalid.

---

## **2️⃣ Service**

| Field             | Can Patch?                  | Notes / Examples                                 |
| ----------------- | --------------------------- | ------------------------------------------------ |
| `metadata.labels` | ✅ Mutable                   | Add environment-specific labels.                 |
| `metadata.name`   | ❌ Immutable                 | Name must match base.                            |
| `spec.selector`   | ✅ Mutable                   | Can override, but should match labels on pods.   |
| `spec.ports`      | ✅ Mutable                   | Can patch ports if needed.                       |
| `spec.type`       | ⚠️ Immutable after creation | Changing ClusterIP type after creation may fail. |

**💡 Tip:** Always check that service selectors match pod labels.

---

## **3️⃣ Secret / ExternalSecret**

| Field               | Can Patch?   | Notes / Examples                                  |
| ------------------- | ------------ | ------------------------------------------------- |
| `metadata.labels`   | ✅ Mutable    | Environment-specific labeling.                    |
| `metadata.name`     | ❌ Immutable  | Name must match base for patching.                |
| `data / stringData` | ✅ Mutable    | Override values per environment.                  |
| `type`              | ⚠️ Immutable | Cannot change type in patch (e.g., Opaque → TLS). |
| `namespace`         | ❌ Immutable  | Namespace is fixed; cannot patch from overlay.    |

---

## **Kustomize Overlay Tips**

1. **Patch only mutable fields**: image, env, labels, resource limits, secrets.
2. **Do not try to patch immutable fields**: name, selector, container name.
3. **Use overlays for environment differences**, not for completely new apps.
4. **Use ExternalSecrets overlays** to point to different Vault paths or Secret names per environment.
5. **Avoid creating base secrets you don’t need**: manage secrets via overlays and external secrets.

---


## **🎯 Base → Overlay → Patch Workflow**

### **1️⃣ Base Folder Structure**

```
base/
├─ mysql/
│   ├─ kustomization.yaml
│   ├─ statefulset.yaml      # base StatefulSet
│   ├─ service.yaml          # base Service
│   └─ secret.yaml           # base Secret (optional)
├─ redis/
│   ├─ kustomization.yaml
│   ├─ statefulset.yaml
│   └─ service.yaml
└─ external-secret.yaml      # Base ExternalSecret pointing to Vault
```

**Example Base StatefulSet**

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: crud-mysql
spec:
  serviceName: crud-mysql
  replicas: 1
  selector:
    matchLabels:
      app: crud-mysql
  template:
    metadata:
      labels:
        app: crud-mysql
    spec:
      containers:
        - name: crud-mysql
          image: crud-mysql:v1
          env:
            - name: MYSQL_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: crud-secrets
                  key: MYSQL_ROOT_PASSWORD
```

---

### **2️⃣ Overlay Folder Structure**

```
overlays/prod/
├─ kustomization.yaml
├─ mysql-patch.yaml         # Only patch mutable fields
├─ external-secret-patch.yaml
```

**Overlay Patch Example – StatefulSet**

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: crud-mysql      # Must match base name
spec:
  template:
    metadata:
      labels:
        env: prod       # Add env label
    spec:
      containers:
        - name: crud-mysql   # Must match base container name
          image: siva9666/crud:mysql-v1  # Override image
          env:
            - name: MYSQL_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: prod-mysql-secret
                  key: MYSQL_ROOT_PASSWORD
```

**Overlay Patch Example – ExternalSecret**

```yaml
apiVersion: external-secrets.io/v1
kind: ExternalSecret
metadata:
  name: external-secret-mysql   # Must match base name
  namespace: crud
spec:
  target:
    name: prod-mysql-secret      # Only override target Secret name
  data:
    - remoteRef:
        key: prod/mysql          # Override Vault path
        property: MYSQL_ROOT_PASSWORD
```

---

### **3️⃣ Overlay Kustomization.yaml**

```yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

resources:
  - ../../../base/mysql
  - ../../../base/redis
  - external-secret-patch.yaml

patches:
  - path: mysql-patch.yaml
    target:
      kind: StatefulSet
      name: crud-mysql
```

**✅ Key Rules**

1. **Name must match base** if you want to patch it.
2. **Patch only mutable fields**:

   * labels
   * env
   * image
   * resource limits
3. **Immutable fields cannot change**:

   * StatefulSet `selector`
   * Container `name`
   * Secret `type`
4. **Use overlay to override per environment** (prod, dev, staging).
5. **ExternalSecrets overlay** can point to different Vault paths or Secret names.

---

This approach ensures:

* Base contains **common configuration** for all environments.
* Overlay applies **environment-specific changes** safely.
* You never accidentally try to patch immutable fields.
* Secrets created by ExternalSecrets don’t collide with base Secrets.

---