# ✅ **Docker & Application Architecture Notes**

---

### **EAR, WAR, JAR**

* **EAR (Enterprise Archive)** = Frontend + Backend (Multiple WARs + JARs)
* **WAR (Web Archive)** = Web application (e.g., for application servers)
* **JAR (Java Archive)** = Java libraries
* **Servlet** = Base for any Java web framework
* **JSP (Java Server Pages)** = Dynamic web pages

---

### ✅ **Traditional Release Process**

* **Steps:**

  1. Add new features / fix defects
  2. Business Analyst + Manager + Leads + Architects + QA + Release Team
  3. Release Manager coordinates all teams
* **Deployment Workflow:**

  * Downtime required
  * Stop application service
  * Remove old EAR
  * Place new EAR
  * Check modules & versions
  * Restart the server
* **Issues:**

  * If major defects → **Rollback**
  * No restart → Application slow or not responding
  * Troubleshooting: Check logs, restart service
* **Critical Incidents:**

  * 2:30 AM slow response → Logs checked → Issue not reproducible
  * **Bridge Call:** Clients + L1/L2 Support + Service Desk + Network + Linux + DB + Testing
* **Architecture:**
  Frontend → Backend
  API = REST API
  Application Servers = **WebSphere, JBoss, WebLogic**
  WAR files deployed on **WildFly/JBoss**

---

### ✅ **Monolithic vs Microservices**

#### **Monolithic**

* If **one module fails**, entire app goes down
* Debugging is complex
* Large application size
* Single technology stack

#### **Microservices**

* Components: **Catalogue, Cart, User, Shipping, Payment**
* **Advantages:**

  * Failure in one service doesn’t break entire app
  * Easy debugging
  * Different languages/frameworks allowed
  * Loose coupling → Less dependency
  * Smaller app size

---

### ✅ **Physical Servers vs VMs vs Containers**

#### **Physical Server**

* No resource boundaries → One app can consume all resources
* If one app overuses resources, others slow down
* **Wastage of resources** when hosting single app

#### **Virtual Machines (VM)**

* Can create **multiple VMs** on one physical server
* Each VM = Dedicated OS + specific resources
* **Cons:**

  * High boot time (full OS)
  * Hosting cost is higher
  * Blocks resources (static allocation)
  * More secure than containers

#### **Containers**

* Lightweight (no full OS, only required libraries)
* Fast boot time → **Rapid scaling**
* Structure: **Minimal OS + System Packages + App Code + Dependencies = Image**
* Consumes **less resources**
* Easy to move between environments
* Resources allocated dynamically (no need to stop container)
* **Less secure than VMs** (but can achieve security)
* **Docker** = Most popular containerization tool

---

### ✅ **Why Containers?**

* Reduce resource usage
* Faster deployment & scaling
* Portability (Dev → QA → Prod)
* Microservices architecture friendly

---