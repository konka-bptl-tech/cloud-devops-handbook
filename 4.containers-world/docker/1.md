# âœ… **Docker & Application Architecture Notes**

---

### **EAR, WAR, JAR**

* **EAR (Enterprise Archive)** = Frontend + Backend (Multiple WARs + JARs)
* **WAR (Web Archive)** = Web application (e.g., for application servers)
* **JAR (Java Archive)** = Java libraries
* **Servlet** = Base for any Java web framework
* **JSP (Java Server Pages)** = Dynamic web pages

---

### âœ… **Traditional Release Process**

* **Steps:**

  1. Add new features / fix defects
  2. Business Analyst + Manager + Leads + Architects + QA + Release Team
  3. Release Manager coordinates all teams
* **Deployment Workflow:**

  * Downtime required
  * Stop application service
  * Remove old EAR
  * Place new EAR
  * Check modules & versions
  * Restart the server
* **Issues:**

  * If major defects â†’ **Rollback**
  * No restart â†’ Application slow or not responding
  * Troubleshooting: Check logs, restart service
* **Critical Incidents:**

  * 2:30 AM slow response â†’ Logs checked â†’ Issue not reproducible
  * **Bridge Call:** Clients + L1/L2 Support + Service Desk + Network + Linux + DB + Testing
* **Architecture:**
  Frontend â†’ Backend
  API = REST API
  Application Servers = **WebSphere, JBoss, WebLogic**
  WAR files deployed on **WildFly/JBoss**

---

### âœ… **Monolithic vs Microservices**

#### **Monolithic**

* If **one module fails**, entire app goes down
* Debugging is complex
* Large application size
* Single technology stack

#### **Microservices**

* Components: **Catalogue, Cart, User, Shipping, Payment**
* **Advantages:**

  * Failure in one service doesnâ€™t break entire app
  * Easy debugging
  * Different languages/frameworks allowed
  * Loose coupling â†’ Less dependency
  * Smaller app size

---

### âœ… **Physical Servers vs VMs vs Containers**

#### **Physical Server**

* No resource boundaries â†’ One app can consume all resources
* If one app overuses resources, others slow down
* **Wastage of resources** when hosting single app

#### **Virtual Machines (VM)**

* Can create **multiple VMs** on one physical server
* Each VM = Dedicated OS + specific resources
* **Cons:**

  * High boot time (full OS)
  * Hosting cost is higher
  * Blocks resources (static allocation)
  * More secure than containers

#### **Containers**

* Lightweight (no full OS, only required libraries)
* Fast boot time â†’ **Rapid scaling**
* Structure: **Minimal OS + System Packages + App Code + Dependencies = Image**
* Consumes **less resources**
* Easy to move between environments
* Resources allocated dynamically (no need to stop container)
* **Less secure than VMs** (but can achieve security)
* **Docker** = Most popular containerization tool

---

### âœ… **Why Containers?**

* Reduce resource usage
* Faster deployment & scaling
* Portability (Dev â†’ QA â†’ Prod)
* Microservices architecture friendly

---

ðŸ§  Interview-Ready Talking Points: VMs vs Containers
ðŸ”¹ High-Level Summary
"VMs and containers are both virtualization technologies, but they differ in how they isolate and manage resources."

ðŸ”¹ Architecture
VMs: Include a full OS, hypervisor, and guest OS per instance.

Containers: Share the host OS kernel, making them lightweight and faster to start.

"VMs virtualize hardware; containers virtualize the OS. Thatâ€™s why containers are more efficient for microservices and CI/CD pipelines."

ðŸ”¹ Performance & Efficiency
VMs: Heavier, slower boot times, more resource-intensive.

Containers: Lightweight, fast startup, better density on the same hardware.

"In my experience, containers drastically reduced deployment time and improved scalability in our cloud-native apps."

ðŸ”¹ Isolation & Security
VMs: Strong isolation due to separate OS.

Containers: Process-level isolation; needs extra security hardening.

"For multi-tenant environments with strict isolation, VMs are safer. But with proper container orchestration and runtime policies, containers can be secure too."

ðŸ”¹ Use Cases
VMs: Legacy apps, monoliths, apps needing full OS.

Containers: Microservices, stateless apps, DevOps workflows.

"We used VMs for legacy ERP systems, but shifted to containers for our new microservices architecture using Kubernetes."