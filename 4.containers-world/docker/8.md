# Dockerfile instructions
Dockerfile is a normal text file it has instructions to build custom images
---

### 1Ô∏è‚É£ **FROM**

* **What it does:** Specifies the **base image** your custom image will be built on.
* **Use case:** Starting your image from Ubuntu, Alpine, or any official image.

```dockerfile
FROM ubuntu:22.04
```

This starts your image using Ubuntu 22.04 as the base.

---

### 2Ô∏è‚É£ **RUN**

* **What it does:** Runs commands **during the image build** stage.
* **Use case:** Installing software, updating packages, or creating directories.

```dockerfile
RUN apt-get update && apt-get install -y curl
```

This installs `curl` in the image.

---

### 3Ô∏è‚É£ **CMD**

* **What it does:** Defines the **default command** to run when the container starts.
* **Use case:** Specify the default app or script to execute.

```dockerfile
CMD ["python3", "app.py"]
```

This runs `python3 app.py` when the container starts.
*(Can be overridden at `docker run` time.)*

---

### 4Ô∏è‚É£ **ENTRYPOINT**

* **What it does:** Also defines the container‚Äôs main process, but is **harder to override** than CMD.
* **Use case:** When you want your container to behave like an executable.

```dockerfile
ENTRYPOINT ["python3", "app.py"]
```

Now the container always runs this command unless you explicitly use `--entrypoint` in `docker run`.

---

### 5Ô∏è‚É£ **EXPOSE**

* **What it does:** Declares which **ports** the container will listen on at runtime.
* **Use case:** Documenting container ports for tools like `docker run -P` or `docker-compose`.

```dockerfile
EXPOSE 8080
```

Tells Docker this app listens on port 8080.

---

### 6Ô∏è‚É£ **COPY**

* **What it does:** Copies **files/folders** from your host machine into the image.
* **Use case:** Copy application code, configuration files.

```dockerfile
COPY ./app /usr/src/app
```

This copies the local `app` folder to `/usr/src/app` inside the image.

---

### 7Ô∏è‚É£ **ADD**

* **What it does:** Like `COPY` but with extra features:

  * Can extract compressed files (tar, gzip) automatically.
  * Can copy from remote URLs.
* **Use case:** When you need auto-extraction or pulling from URL.

```dockerfile
ADD myapp.tar.gz /usr/src/app/
```

This extracts `myapp.tar.gz` automatically inside the image.

---

### 8Ô∏è‚É£ **WORKDIR**

* **What it does:** Sets the **current working directory** for subsequent instructions (RUN, CMD, ENTRYPOINT, etc.).
* **Use case:** Avoid writing full paths repeatedly.

```dockerfile
WORKDIR /usr/src/app
```

Now all next instructions run inside `/usr/src/app`.

---

### 9Ô∏è‚É£ **USER**

* **What it does:** Sets the **user** under which the container runs commands.
* **Use case:** Security ‚Äî run your app as a non-root user.

```dockerfile
USER appuser
```

All following commands run as `appuser`, not root.

---

### Quick Table for Reference

| Instruction    | Purpose                        | When to Use                                  |
| -------------- | ------------------------------ | -------------------------------------------- |
| **FROM**       | Base image                     | Start with OS or runtime base                |
| **RUN**        | Execute commands at build time | Install software                             |
| **CMD**        | Default command to run         | Default process for container                |
| **ENTRYPOINT** | Main executable                | Force a specific command                     |
| **EXPOSE**     | Document ports                 | Show which ports app uses                    |
| **COPY**       | Copy files                     | Move local files to image                    |
| **ADD**        | Copy + extract/URL             | When you need tar extraction or URL download |
| **WORKDIR**    | Set working directory          | Avoid repeating paths                        |
| **USER**       | Set container user             | Run as non-root for security                 |

---

## 1Ô∏è‚É£ **Difference between RUN & CMD**

| Feature          | **RUN**                                                                | **CMD**                                                                   |
| ---------------- | ---------------------------------------------------------------------- | ------------------------------------------------------------------------- |
| **When it runs** | At **build time** (when you run `docker build`)                        | At **container start time** (when you run `docker run`)                   |
| **Effect**       | Executes commands **once** and commits the result into the image layer | Defines the **default command** that runs every time the container starts |
| **Use case**     | Install packages, update OS, create directories                        | Start the main application or script in the container                     |

**Example:**

```dockerfile
FROM ubuntu:22.04
RUN apt-get update && apt-get install -y nginx   # build time
CMD ["nginx", "-g", "daemon off;"]              # runtime
```

---

## 2Ô∏è‚É£ **Difference between COPY & ADD**

| Feature                      | **COPY**                                | **ADD**                                                                              |
| ---------------------------- | --------------------------------------- | ------------------------------------------------------------------------------------ |
| **Function**                 | Copies files/folders from host to image | Same as COPY **plus** extra features                                                 |
| **Extra features**           | None                                    | - Can extract compressed files automatically (tar, gzip)<br>- Can download from URLs |
| **Security / Best Practice** | Safer and more predictable              | Should only be used when you really need the extra features                          |
| **Use case**                 | Always prefer COPY for local files      | Use ADD only for tar extraction or remote URLs                                       |

**Example:**

```dockerfile
# COPY - simple copy
COPY ./app /usr/src/app

# ADD - extracts automatically
ADD app.tar.gz /usr/src/app  # will untar automatically
```

---

## 3Ô∏è‚É£ **Difference between CMD & ENTRYPOINT + Best Practice**

| Feature        | **CMD**                                           | **ENTRYPOINT**                                                               |
| -------------- | ------------------------------------------------- | ---------------------------------------------------------------------------- |
| **Purpose**    | Provides **default command**                      | Provides **main executable**                                                 |
| **Overriding** | Easily overridden by arguments to `docker run`    | Harder to override ‚Äî arguments are appended to ENTRYPOINT                    |
| **Behavior**   | If you pass args to `docker run`, CMD is replaced | If you pass args to `docker run`, they are added as extra args to ENTRYPOINT |
| **Use case**   | Use for default options                           | Use when you want your container to behave like a fixed executable           |

---

**Example:**

```dockerfile
# CMD Example
FROM python:3.11
COPY app.py /app/
CMD ["python", "/app/app.py"]
```

Run:

```bash
docker run myimage python /app/other.py  # overrides CMD
```

---

```dockerfile
# ENTRYPOINT Example
FROM python:3.11
COPY app.py /app/
ENTRYPOINT ["python", "/app/app.py"]
```

Run:

```bash
docker run myimage arg1 arg2  # runs python /app/app.py arg1 arg2
```

---

### ‚úÖ **Best Practice**

* **Use ENTRYPOINT** to specify the main executable (like `python`, `nginx`, or your binary).
* **Use CMD** to specify default arguments for that executable.
* This allows you to have a stable main process but still customize arguments easily.

**Best Practice Example:**

```dockerfile
FROM ubuntu:22.04
ENTRYPOINT ["ping"]         # fixed command
CMD ["localhost"]           # default argument
```

Run:

```bash
docker run myimage           # runs: ping localhost
docker run myimage google.com  # runs: ping google.com
```

---
## üê≥ Docker Image Layers Explained & Dockerfile best practices

* A **Docker image** is a **collection of read-only layers** stacked on top of each other.
* Each **instruction** in the Dockerfile (like `FROM`, `RUN`, `COPY`, etc.) creates a **new layer** in the image.
* When you build an image with:

  ```bash
  docker build -t myimage:1.0 .
  ```

  Docker executes the **Dockerfile instructions from top to bottom** and stacks the layers.

---

### üìù How Docker Caching Works

* Docker **caches** each layer after it‚Äôs built.
* When you rebuild the image:

  * If an instruction **and all previous layers** haven‚Äôt changed, Docker will **reuse** the cached layer instead of rebuilding it.
  * If an instruction changes, Docker **invalidates the cache** for that layer **and all the layers after it**.
* Example:

  * **Dockerfile 1** ‚Äì 5 instructions ‚Üí 5 layers cached.
  * **Dockerfile 2** ‚Äì instruction 3 and 4 changed ‚Üí Docker will:

    * Reuse layers 1 and 2 from cache.
    * Rebuild layers 3, 4, and 5 (because cache breaks at 3).

---

### üîÑ Sequence Matters

* Caching depends on the **sequence** of instructions.
* If you move or rearrange instructions, Docker treats them as new layers and rebuilds them.

---

### ‚úÖ Best Practice for Faster Builds

1. **Put unchanged instructions at the top**

   * Example: base image, OS updates, installing system packages.
2. **Put frequently changed instructions at the bottom**

   * Example: copying application code, environment variables, config files.

This maximizes Docker‚Äôs caching and makes builds **faster**.

---

### üìå Visual Example

```dockerfile
# Good practice
FROM python:3.11              # rarely changes
RUN apt-get update && apt-get install -y curl  # rarely changes
WORKDIR /app
COPY requirements.txt .        # changes occasionally
RUN pip install -r requirements.txt
COPY . .                       # changes frequently
CMD ["python", "app.py"]
```

Here:

* Layers up to `RUN pip install` are reused most of the time.
* Only `COPY . .` and `CMD` rebuild when code changes.

---



- container is running process of a program as long as process runs containers live if process exists container dies
- 

