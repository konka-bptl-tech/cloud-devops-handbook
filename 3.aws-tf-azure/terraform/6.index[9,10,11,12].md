## **9. Provisioners**

Provisioners are used to **execute scripts or commands on a resource** after it is created or before it is destroyed. They are **not the primary way to manage infrastructure** in Terraform, but they can help in special cases.

---

### **1. `local-exec`**

* **Purpose:** Run a command on the **machine where Terraform is running**.
* **Example:**

```hcl
resource "aws_instance" "web" {
  ami           = "ami-12345678"
  instance_type = "t2.micro"

  provisioner "local-exec" {
    command = "echo ${self.public_ip} >> ip_list.txt"
  }
}
```

* **Use case:**

  * Generating local files
  * Triggering external scripts or tools
  * Sending notifications

---

### **2. `remote-exec`**

* **Purpose:** Run a command **on the created resource** (typically via SSH).
* **Example:**

```hcl
resource "aws_instance" "web" {
  ami           = "ami-12345678"
  instance_type = "t2.micro"

  provisioner "remote-exec" {
    inline = [
      "sudo apt-get update",
      "sudo apt-get install -y nginx"
    ]

    connection {
      type        = "ssh"
      user        = "ubuntu"
      private_key = file("~/.ssh/id_rsa")
      host        = self.public_ip
    }
  }
}
```

* **Use case:**

  * Installing software
  * Configuring the instance
  * Running post-deployment scripts

---

### **3. When to Use Provisioners**

* Only use when **Terraform cannot manage the resource itself**.
* Common scenarios:

  * Bootstrapping servers with software installation
  * Triggering scripts after resource creation
  * Migrating or copying files to instances

**Important:** Prefer **native Terraform resources or configuration management tools** (like Ansible, Chef, Puppet) over provisioners when possible.

---

### **4. Best Practices & Limitations**

**Best Practices:**

1. **Minimize use** — only for tasks Terraform cannot manage.
2. Use **`remote-exec` with `connection` blocks`** for clarity.
3. Consider using **`null_resource`** with triggers to separate provisioning logic.
4. Handle errors gracefully and test scripts outside Terraform first.

**Limitations:**

* **Not idempotent** — may run multiple times if state changes.
* **Hard to manage at scale** — provisioning many resources can be slow.
* **Tightly couples infrastructure and configuration** — breaks Terraform’s declarative model.
* **Failure-sensitive** — if a provisioner fails, `terraform apply` fails.

---

### **5. Example with `null_resource` & Trigger**

* To **decouple provisioning from actual resources**:

```hcl
resource "null_resource" "provision_web" {
  triggers = {
    instance_id = aws_instance.web.id
  }

  provisioner "remote-exec" {
    inline = [
      "sudo apt-get update",
      "sudo apt-get install -y nginx"
    ]
    connection {
      type        = "ssh"
      user        = "ubuntu"
      private_key = file("~/.ssh/id_rsa")
      host        = aws_instance.web.public_ip
    }
  }
}
```

* **Benefit:** Provisioning runs **only when triggers change**, not every `apply`.

---

Here’s a detailed, interview-ready explanation for your **Terraform Functions** section:

---

## **10. Functions**

Terraform functions are **built-in utilities** that let you **manipulate data, perform calculations, and generate dynamic values** in your configuration. They work with **variables, outputs, resources, and modules**.

---

### **1. Built-in Terraform Functions**

Terraform provides functions in several categories:

1. **String functions** – manipulate text
2. **Numeric functions** – perform arithmetic
3. **Collection functions** – work with lists, maps, and sets
4. **Date/Time functions** – work with timestamps
5. **Encoding/Decoding functions** – e.g., base64 encode/decode
6. **File functions** – read content from files

---

### **2. String Functions**

* **`lower()` / `upper()`** – convert string case
* **`replace()`** – replace substring
* **`join()` / `split()`** – join or split strings
* **Example:**

```hcl
variable "env" {
  default = "PROD"
}

output "lower_env" {
  value = lower(var.env)  # prod
}
```

---

### **3. Numeric Functions**

* **`max()` / `min()`** – return max or min value
* **`abs()`** – absolute value
* **Example:**

```hcl
variable "disk_sizes" {
  default = [10, 20, 15]
}

output "max_size" {
  value = max(var.disk_sizes...)  # 20
}
```

---

### **4. Collection Functions**

* **`length()`** – number of elements in list/map
* **`keys()` / `values()`** – get keys or values from map
* **`lookup()`** – get map value with default
* **`flatten()` / `compact()`** – manipulate nested lists
* **Example:**

```hcl
variable "servers" {
  default = {
    web1 = "t2.micro"
    web2 = "t2.small"
  }
}

output "server_names" {
  value = keys(var.servers)  # ["web1", "web2"]
}
```

---

### **5. Interpolation Syntax**

* Terraform uses **`${}`** to reference variables, outputs, or expressions in strings.
* **Example:**

```hcl
resource "aws_instance" "web" {
  ami           = "ami-12345678"
  instance_type = "t2.micro"
  tags = {
    Name = "${var.env}-webserver"
  }
}
```

* **Note:** Since Terraform 0.12+, you can **omit `${}`** for simple expressions:

```hcl
tags = {
  Name = "${var.env}-webserver"  # old
  Name = "${var.env}-webserver"  # new style (simpler)
}
```

---

### **6. Key Points for Interviews**

* String, numeric, and collection functions are most commonly asked.
* Be ready to **combine functions**, e.g., `join("-", keys(var.map))`.
* Always **use interpolation** to make configuration dynamic.
* Understand **how functions behave with lists and maps**, especially in `for_each` and `count`.

---

If you want, I can next make **Terraform Dynamic Blocks section** with **examples of iterating lists/maps and practical interview scenarios** — fully ready.
---
Here’s a detailed, interview-ready explanation for your **Terraform Dynamic Block** section:

---

## **11. Dynamic Block**

Dynamic blocks in Terraform allow you to **generate multiple nested blocks programmatically**, especially when the number of nested blocks is **not known beforehand**. They are useful when working with **repeating configuration elements** like security group rules, tags, or listeners.

---

### **1. When to Use `dynamic` Blocks**

* Use dynamic blocks when:

  1. You have **variable number of nested blocks**.
  2. You want to **iterate over a list or map** to generate configuration dynamically.
  3. Static definition of nested blocks is **not practical or scalable**.

**Common use-cases:**

* Security group rules (ingress/egress)
* Tags for resources
* Listeners in load balancers
* IAM policies with multiple statements

---

### **2. Iterating Over Lists & Maps**

* Syntax:

```hcl
dynamic "BLOCK_NAME" {
  for_each = var.list_or_map
  content {
    # block attributes using BLOCK_NAME.value
  }
}
```

* **`BLOCK_NAME.value`** gives access to each element of the list or map.

---

### **3. Example 1: Security Group Rules**

```hcl
variable "ingress_rules" {
  default = [
    { from_port = 80, to_port = 80, protocol = "tcp", cidr = "0.0.0.0/0" },
    { from_port = 443, to_port = 443, protocol = "tcp", cidr = "0.0.0.0/0" }
  ]
}

resource "aws_security_group" "web_sg" {
  name        = "web_sg"
  description = "Web security group"

  dynamic "ingress" {
    for_each = var.ingress_rules
    content {
      from_port   = ingress.value.from_port
      to_port     = ingress.value.to_port
      protocol    = ingress.value.protocol
      cidr_blocks = [ingress.value.cidr]
    }
  }
}
```

* Terraform will **create 2 ingress rules dynamically** based on the list.

---

### **4. Example 2: Tags from a Map**

```hcl
variable "tags" {
  default = {
    Environment = "Prod"
    Team        = "DevOps"
  }
}

resource "aws_instance" "web" {
  ami           = "ami-12345678"
  instance_type = "t2.micro"

  dynamic "tags" {
    for_each = var.tags
    content {
      key   = tags.key
      value = tags.value
    }
  }
}
```

* Generates tags dynamically for the instance.

---

### **5. Key Points for Interviews**

* `dynamic` blocks are **not mandatory**, but useful for **scalable configurations**.
* They are used **inside a resource block** to generate **nested blocks dynamically**.
* Know **difference between dynamic blocks vs static blocks**: dynamic = flexible, static = fixed.
* Often combined with **variables, lists, maps, and modules**.

---
Here’s a detailed, interview-ready explanation for your **Terraform Import** section:

---

## **12. Import**

Terraform `import` is used to **bring existing infrastructure under Terraform management** without recreating resources. It **maps real resources to Terraform state**.

---

### **1. `terraform import` Basics**

* **Purpose:** Import existing cloud resources into Terraform state.
* **Command Syntax:**

```bash
terraform import [options] <RESOURCE_TYPE>.<NAME> <RESOURCE_ID>
```

* **Example:**

```bash
terraform import aws_instance.web i-0123456789abcdef0
```

* **Effect:** Adds the EC2 instance to Terraform state without creating or changing it.

---

### **2. Importing Existing Resources**

* Steps to import:

1. **Define the resource** in Terraform code (matching the existing resource).

```hcl
resource "aws_instance" "web" {
  # Only required attributes for import; later you can expand
  ami           = "ami-12345678"
  instance_type = "t2.micro"
}
```

2. **Run terraform import** with the resource ID.
3. Terraform updates **state file** to include this resource.

---

### **3. Mapping to Terraform State**

* Terraform uses the **resource address** (like `aws_instance.web`) to map the real resource to the state.
* After import, you **must ensure Terraform code matches the actual resource attributes**, otherwise `terraform plan` may show changes.
* **Tip:** Use `terraform state show <resource>` to inspect imported resources.

---

### **4. Handling Complex Dependencies During Import**

* Some resources have **nested or dependent resources** (e.g., VPC → Subnet → EC2).
* **Best practices:**

  1. **Import in dependency order** (parent first, children later).
  2. Use `terraform state list` to verify imported resources.
  3. Adjust Terraform code to reflect all attributes for **accurate state mapping**.
* **Example:**

```bash
# Import VPC first
terraform import aws_vpc.main vpc-12345678

# Then import subnet
terraform import aws_subnet.public_subnet subnet-abcdef01
```

* Helps avoid **unwanted recreation** of dependent resources.

---

### **5. Key Points for Interviews**

* Import **does not create or modify resources**, only updates Terraform state.
* Terraform code **must exist before importing**; import alone is not enough.
* Always **check attributes after import** to ensure state is correct.
* Useful for **migrating existing infra to Terraform** gradually.

---

