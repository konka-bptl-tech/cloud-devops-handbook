## **7. Local State & Remote State**

### **1. What is Terraform State**

* Terraform state is a **snapshot of your infrastructure** at a given time.
* **Purpose:**

  * Keeps track of resources created by Terraform.
  * Maps real infrastructure to your configuration (`.tf` files).
  * Enables **incremental changes** — Terraform knows what to create, update, or delete.
* **File:** `terraform.tfstate`

**Example:**

```json
{
  "resources": [
    {
      "type": "aws_instance",
      "name": "web",
      "id": "i-0123456789abcdef0",
      "attributes": { "ami": "ami-12345678", "instance_type": "t2.micro" }
    }
  ]
}
```

---

### **2. Local vs Remote State**

| Feature    | Local State                                | Remote State                                    |
| ---------- | ------------------------------------------ | ----------------------------------------------- |
| Location   | Stored on local disk (`terraform.tfstate`) | Stored in backend (S3, Terraform Cloud, Consul) |
| Multi-user | Not safe for teams                         | Safe for teams with locking                     |
| Backup     | Manual                                     | Automatic (versioning in S3)                    |
| Security   | Manual encryption                          | Supports encryption & access control            |
| Best for   | Single dev / small projects                | Production / multi-user projects                |

**Tip:** For team projects, **always use remote state**.

---

### **3. Backend Types**

* **S3** (AWS) – common for production; supports versioning & DynamoDB for locking.
* **Terraform Cloud** – provides remote runs, state management, and collaboration.
* **Consul** – HashiCorp backend, good for large-scale multi-cloud infra.
* **Local** – default, good for experiments or single-user setups.

**Example S3 backend configuration:**

```hcl
terraform {
  backend "s3" {
    bucket         = "my-terraform-state"
    key            = "project/terraform.tfstate"
    region         = "us-east-1"
    dynamodb_table = "terraform-lock"
    encrypt        = true
  }
}
```

---

### **4. Locking & State Management**

* **Why:** Prevent **simultaneous changes** that can corrupt state.
* **How:**

  * DynamoDB table with S3 backend
  * Terraform Cloud automatically locks state
* **Commands:**

```bash
terraform state list      # List all resources
terraform state show      # Show details of a resource
terraform state rm        # Remove resource from state
terraform state mv        # Move resource between names/modules
```

---

### **5. Handling Resource Drift**

* **Drift:** When real infrastructure changes outside Terraform.
* **Detection & Fix:**

```bash
terraform plan        # Shows drift between state & real infra
terraform refresh     # Reconciles state with real infra
terraform apply       # Updates infra according to Terraform config
```

**Best Practice:** Avoid manual changes; always use Terraform.

---

### **6. Managing State Conflicts in Multi-User Setups**

* **Problem:** Multiple users applying changes simultaneously can corrupt state.
* **Solutions:**

  * Use **remote backend** with locking (S3 + DynamoDB or Terraform Cloud)
  * Implement **approval workflows** (CI/CD pipelines)
  * Use **terraform workspace** for isolated environments
  * Regularly **backup state**

**Tip:** Always plan → review → apply. Never directly `apply` without planning in a shared setup.

---
