### **1. What Are Workspaces**

* A workspace is an **isolated state environment**.
* By default, Terraform has a single workspace called `default`.
* Switching workspaces **changes which state file Terraform uses**, allowing the same code to manage multiple environments.

---

### **2. Default vs Custom Workspaces**

| Feature    | Default Workspace   | Custom Workspace                                    |
| ---------- | ------------------- | --------------------------------------------------- |
| Name       | `default`           | Any name you choose (e.g., dev, prod)               |
| State file | `terraform.tfstate` | `terraform.tfstate.d/<workspace>/terraform.tfstate` |
| Use case   | Single environment  | Multiple environments                               |
| Creation   | Automatic           | `terraform workspace new <name>`                    |

---

### **3. Managing Multiple Environments**

* **Commands:**

```bash
terraform workspace list            # List all workspaces
terraform workspace show            # Show current workspace
terraform workspace new dev         # Create new workspace
terraform workspace select prod     # Switch to another workspace
terraform workspace delete test     # Delete a workspace
```

* **Example:** Using workspaces for dev, staging, and prod:

```bash
terraform workspace new dev
terraform apply

terraform workspace new staging
terraform apply

terraform workspace new prod
terraform apply
```

* **Effect:** Same Terraform code deploys to three different environments with **isolated states**.

* **Tips:**

  1. Use **workspace-specific variables**:

  ```hcl
  variable "instance_type" {
    type = string
    default = terraform.workspace == "prod" ? "t3.large" : "t2.micro"
  }
  ```

  2. Combine **workspaces with modules** for reusable and environment-specific infra.
  3. Avoid hardcoding values; always use workspace or variable-driven configurations.

---

### **4. Key Points for Interviews**

* Workspaces = **state isolation for multiple environments**.
* Default workspace = single environment; custom workspaces = dev/staging/prod.
* **Best practice:** Use workspaces for **small-medium infra**, and **Terraform Cloud/remote backend** for large production setups.

---
### **1. Terraform Configuration (Same Infra)**

```hcl
# main.tf
provider "aws" {
  region = "us-east-1"
}

resource "aws_s3_bucket" "my_bucket" {
  bucket = "my-bucket-${terraform.workspace}"  # bucket name changes per workspace
  acl    = "private"
}

output "bucket_name" {
  value = aws_s3_bucket.my_bucket.id
}
```

---

### **2. Backend Configuration (Separate State per Workspace)**

```hcl
# backend.tf
terraform {
  backend "s3" {
    bucket         = "terraform-states"
    key            = "${terraform.workspace}/terraform.tfstate"
    region         = "us-east-1"
    dynamodb_table = "terraform-locks"
    encrypt        = true
  }
}
```

* Here, the **same S3 bucket resource** will be deployed in **dev, staging, and prod workspaces**, but:

  * Each workspace uses a **different key in the backend S3 bucket** (isolated state).
  * Terraform locks in DynamoDB table prevent conflicts.

---

### **3. Commands**

```bash
terraform init                       # Initialize Terraform with backend
terraform workspace new dev           # Create dev workspace
terraform apply                       # Deploy S3 bucket: my-bucket-dev

terraform workspace new prod          # Create prod workspace
terraform apply                       # Deploy S3 bucket: my-bucket-prod

terraform workspace list              # Check available workspaces
terraform workspace select dev        # Switch back to dev
```

---

### **4. Key Points**

* **Same code, different environments** → avoid duplication.
* **Bucket name changes using `${terraform.workspace}`** to prevent collisions.
* **Backend state separated by workspace** → dev/prod isolation.
* **Best practice:** Combine **workspace-based variables** for environment-specific configurations (e.g., instance type, VPC IDs).

---
